/*1.	In SQL Server, assuming you can find the result by using both joins and subqueries, 
which one would you prefer to use and why?
Usually join because join will have a better perforamnce than subquery

2.	What is CTE and when to use it?
CTE is short for Common Table Expression. 
When we need to generate hierarchy and we use it in recursive query to make query more readable.

3.	What are Table Variables? What is their scope and where are they created in SQL Server?
1) Table Variable is a special type of variable that helps to store data temporarily. 
2) The table variable scope is within the batch. 
We can define a table variable inside a stored procedure and function as well. 
In this case, the table variable scope is within the stored procedure and function. 
We cannot use it outside the scope of the batch, stored procedure or function.
3) Table variable will store in the physical memory for some of the data, 
then later when the size increases it will be moved to the tempdb.
In fact, the table variable provides all the properties of the local variable, 
but the local variables have some limitations, unlike temp or regular tables.

4.	What is the difference between DELETE and TRUNCATE? 
Which one will have better performance and why?
1) The DELETE command is used to delete specified rows(one or more).	
While this command is used to delete all the rows from a table.
2) DELETE is a DML(Data Manipulation Language) command.	
While TRUNCATE is a DDL(Data Definition Language) command.
3) There may be WHERE clause in DELETE command in order to filter the records.	
While there may not be WHERE clause in TRUNCATE command.
4) In the DELETE command, a tuple is locked before removing it.	
While in this command, data page is locked before removing the table data.
5) The DELETE statement removes rows one at a time and records an entry 
in the transaction log for each deleted row.
TRUNCATE TABLE removes the data by deallocating the data pages used to store the table data 
and records only the page deallocations in the transaction log.
6) DELETE command is slower than TRUNCATE command.	
While TRUNCATE command is faster than DELETE command.
7) To use Delete you need DELETE permission on the table.	
To use Truncate on a table we need at least ALTER permission on the table.
8) Identity of column retains the identity after using DELETE Statement on table.	
Identity of the column is reset to its seed value if the table contains an identity column.
9) The delete can be used with indexed views.	
Truncate cannot be used with indexed views.

5.	What is Identity column? How does DELETE and TRUNCATE affect it?
1) An identity column is a column (also known as a field) in a database table 
that is made up of values generated by the database. It is a column of automatic integer.
2) Identity of column retains the identity after using DELETE Statement on table.	
Identity of the column is reset to its seed value if the table contains an identity column.

6.	What is difference between "delete from table_name" and "truncate table table_name"?
Identity of column retains the identity after using DELETE Statement on table.	
Identity of the column is reset to its seed value if the table contains an identity column.
*/

use Northwind
go
--1.	List all cities that have both Employees and Customers.
select a.City
from (select distinct City
from Customers) as a
join (select distinct City
from Employees) as b on a.City = b.City

--2.	List all cities that have Customers but no Employee.
--a.	Use sub-query
select distinct c.City
from Customers c
where c.City not in (select e.City
from Employees e)

--b.	Do not use sub-query
select distinct City
from Customers
except
select distinct City
from Employees

--3.	List all products and their total order quantities throughout all orders.
select p.ProductName, a.TotalQuantities
from Products p
left join (select ProductID, sum(Quantity) as TotalQuantities
from [Order Details]
group by ProductID) a
on p.ProductID = a.ProductID

--4.	List all Customer Cities and total products ordered by that city.
select c.City, a.TotalOrdered
from Customers c 
left join (select shipPostalCode, count(shipPostalCode) as TotalOrdered
from Orders
group by shipPostalCode) a
on c.PostalCode = a.shipPostalCode

--5.	List all Customer Cities that have at least two customers.
select City
from Customers
group by City
having COUNT(CustomerID)>=2
--a.	Use union？？？
select City
from Customers
group by City
having COUNT(CustomerID)=2
union
select City
from Customers
group by City
having COUNT(CustomerID)>2
--b.	Use sub-query and no union
select a.City
from (select City, customerID
from Customers) a
group by a.City
having count(a.CustomerID) >= 2

--6.	List all Customer Cities that have ordered at least two different kinds of products.
Select C.City
from Customers c
join (select o.ShipPostalCode, count(od.ProductID) as NumOfProducts
from Orders o
join [Order Details] od on o.OrderID = od.OrderID
group by o.ShipPostalCode) a on c.PostalCode = a.ShipPostalCode
where a.NumOfProducts >= 2

--7.	List all Customers who have ordered products, but have the 'ship city'
--on the order different from their own customer cities.
select a.CustomerID
from 
(select CustomerID, ShipPostalCode
from Orders
except
select CustomerID, PostalCode
from Customers) a

--8.	List 5 most popular products, their average price, 
--and the customer city that ordered most quantity of it.
select a.ProductID, a.avgPrice, b.ShipCity as CustomerCity
from
(select Top 5 ProductID, sum(Quantity) as TheSum, sum(UnitPrice*(1-Discount)*Quantity)/sum(Quantity) as avgPrice
from [Order Details]
group by ProductID
order by TheSum desc) a
left join
(select o.ShipCity, od.ProductID, sum(Quantity) as SumQuantity, rank() over (partition by od.ProductID order by sum(Quantity) desc) RNK
from Orders o
join [Order Details] od on o.orderID = od.OrderID
group by o.ShipCity, od.ProductID) b on a.ProductID = b.ProductID
where b.RNK = 1

--9.	List all cities that have never ordered something but we have employees there.
--a.	Use sub-query
select City
from Employees
where City not in (select ShipCity
from Orders)
--b.	Do not use sub-query
Select City
from Employees
Except
Select Shipcity
from Orders

--10.	List one city, if exists, 
--that is the city from where the employee sold most orders (not the product quantity) is, 
--and also the city of most total quantity of products ordered from. (tip: join  sub-query)
select a.City
from (select top 1 e.City, count(o.orderID) as CountOrder
from orders o
join Employees e on o.EmployeeID = e.EmployeeID
group by e.City
order by 2 desc) a
join 
(select top 1 e.City, sum(od.Quantity) as sumQuantity
from [Order Details] od 
join orders o on od.OrderID = o.OrderID
join Employees e on o.EmployeeID = e.EmployeeID
group by e.City
order by sumQuantity desc) b on a.City = b.City

/*11. How do you remove the duplicates record of a table? 
Insert the distinct rows from the duplicate rows table to new temporary table. 
Then delete all the data from duplicate rows table then insert all data from temporary table 
which has no duplicates as shown below.
If there is primary key or identity column in the table, we could first create an cte 
use window function row_number() and delete those whose row_numbers are greater than 1.
*/

--12. Sample table to be used for solutions below- 
--Employee (empid integer, mgrid integer, deptid integer, salary money) 
--Dept (deptid integer, deptname varchar(20))
--Find employees who do not manage anybody.
with empHierarchyCTE
as (select empid, mgrid, 1 lvl
from Employee where mgrid is null
union all
select e.empid, e.mgrid, ct.lvl+1
from employee e join empHierarchy ct on e.mgrid = ct.empid)

--13. Find departments that have maximum number of employees. 
--(solution should consider scenario having more than 1 departments 
--that have maximum number of employees). Result should only have - 
--deptname, count of employees sorted by deptname.
with CountempCTE
as
(
select d.deptid, count(e.empid) as countofemp from Dept d
join Employee e on d.deptid = e.deptid group by d.deptid
)
select d.deptname, c.countofemp
from CountempCTE c
join Dept d on c.deptid = d.deptid
where c.countofemp = (select max(c.countofemp) from CountempCTE c)
order by deptname

/*14. Find top 3 employees (salary based) in every department. 
Result should have deptname, empid, salary sorted by deptname 
and then employee with high to low salary.*/
select a.deptname, a.empid, a.salary
from
(select d.deptname, e.empid, e.salary, rank() over (partition by d.deptname order by e.salary desc) RNK
from dept d
join employee e on d.deptid = e.deptid) a
where RNK <= 3
order by a.deptname, a.salary desc
